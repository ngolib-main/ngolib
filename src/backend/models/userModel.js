// NOTE: Code partially generated by AI.

const db = require("../config/db");       // Include the db configuration file
const bcrypt = require("bcryptjs");                // Needed for passwords hashing

// Function to create a user with its hashed password
const createUser = async (username, email, password, isNGO) => {
    try {
        const userType = isNGO ? "NGO" : "user";
        const hashedPassword = await bcrypt.hash(password, 10);
        return new Promise((resolve, reject) => {
            const sql = "INSERT INTO users (username, email, pw_hash, type) VALUES (?, ?, ?, ?)";
            db.query(sql, [username, email, hashedPassword, userType], (err, result) => {
                if (err) return reject(err);
                resolve(result);
            });
        });
    } catch (error) {
        throw new Error(error);
    }
};

// Function to find a user by email
const findUserByEmail = async (email) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT user_id, username, email, pw_hash, type FROM users WHERE email = ?";
        db.query(query, [email], (err, results) => {
            if (err) {
                return reject(err);
            }
            if (results.length === 0) {
                return resolve(null); // No user found
            }
            resolve(results[0]); // Return user data
        });
    });
};


const findUserById = async (id) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT email, username, type FROM users WHERE user_id = ?";
        db.query(query, [id], (err, results) => {
            if (err) {
                return reject(err);
            }
            if (results.length === 0) {
                return resolve(null); // No user found
            }
            resolve(results[0]); // Return user data
        });
    });
}

// Function to find a user by password reset token.
const findByToken = async (token) => {
    if (!token) {
        return {error: 'Token is required', status: 400};
    }

    try {
        // Execute query with promise interface
        const rows = await new Promise((resolve, reject) => {
            const query = "SELECT user_id, email FROM users where user_id = (SELECT user_id FROM reset_tokens WHERE token = ? AND expiry > NOW() AND consumed = 0)";
            db.query(query, [token], (err, results) => {
                if (err) {
                    return reject(err);
                }
                resolve(results);
            });
        });

        if (rows.length === 0) {
            return {error: 'Invalid or expired token', status: 404};
        }

        // Return user data
        return {
            user_id: rows[0].user_id,
            email: rows[0].email,
            status: 200
        };
    } catch (error) {
        console.error('Error finding user by token:', error);
        return {error: error.message, status: 500};
    }
};

// Function to create a user with its hashed password
const updatePassword = async (user_id, password) => {
    try {
        //console.log("Data that got to updatePassword:")
        //console.log(user_id, password);
        const hashedPassword = await bcrypt.hash(password, 10);
        return new Promise((resolve, reject) => {
            const sql = "UPDATE users SET pw_hash = ? WHERE user_id = ?";
            db.query(sql, [hashedPassword, user_id], (err, result) => {
                if (err) return reject(err);
                //console.log("Result of updatePassword:")
                //console.log(result);
                if (result.changedRows === 1) {
                    resolve({status: 200, message: 'Password updated successfully'});
                    consumeToken(user_id);
                    //console.log("Password updated successfully")
                }
            });
        });
    } catch (error) {
        throw new Error(error);
    }
};

const consumeToken = async (userid) => {
    try {
        const query = "UPDATE reset_tokens SET consumed = 1 WHERE user_id = ?";
        await db.promise().query(query, [userid]);
    } catch (error) {
        console.error('Error consuming token:', error);
        throw error;
    }
}

const storeResetToken = async (userId, token, expiry) => {
    const query = 'INSERT INTO reset_tokens (user_id, token, expiry) VALUES (?, ?, ?)';
    try {
        await db.promise().query(query, [userId, token, expiry]);
    } catch (error) {
        console.error('Error storing reset token:', error);
        throw error;
    }
};

const fetchUserFollowings = async (id) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT n.ngo_id, n.name AS ngo_name FROM ngo_followers AS nf JOIN ngo AS n ON nf.ngo_id = n.ngo_id WHERE nf.user_id = ?;"
        db.query(query, [id], (err, result) => {
            if (err) {
                return reject(err)
            }
            if (result.length === 0) {
                return resolve(null)
            }
            resolve(result)
        });
    });
}

const fetchUserSubscription = async (id) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT s.ngo_id, n.name AS ngo_name, s.status,  s.amount FROM subscriptions AS s JOIN ngo AS n ON s.ngo_id = n.ngo_id WHERE s.user_id = ?;"
        db.query(query, [id], (err, result) => {
            if (err) {
                return reject(err)
            }
            if (result.length === 0) {
                return resolve(null)
            }
            resolve(result)
        });
    });
}
const fetchUserDonation = async (id) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT n.name AS ngo_name, d.amount FROM donations AS d JOIN ngo AS n ON d.ngo_id = n.ngo_id WHERE d.user_id = ?;"
        db.query(query, [id], (err, result) => {
            if (err) {
                return reject(err)
            }
            if (result.length === 0) {
                return resolve(null)
            }
            resolve(result)
        });
    });
}

const storeUserImage = async (id, imageBlob) => {
    return new Promise((resolve, reject) => {
        const query = "INSERT INTO user_images (user_id, image) VALUES (?, ?) ON DUPLICATE KEY UPDATE image = VALUES(image);";

        db.query(query, [id, imageBlob], (err, result) => {
            if (err) {
                return reject(err);
            }
            resolve(result);
        });
    });
};

const fetchUserImage = async (userId) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT image FROM user_images WHERE user_id = ?";

        db.query(query, [userId], (err, results) => {
            if (err) {
                return reject(err);
            }
            if (results.length === 0) {
                return resolve(null);
            }
            resolve(results[0].image);
        });
    });
};

const deleteUserSubscription = async (userId, ngoId) => {
    const query = 'UPDATE subscriptions SET status = \'canceled\' WHERE user_id = ? AND ngo_id = ?;';
    try {
        const [result] = await db.promise().query(query, [userId, ngoId]);
        return result;
    } catch (error) {
        throw error;
    }
};

//perform payment
const addDonate = async (userId, ngoId, amount) => {
    const query = 'INSERT INTO donations (ngo_id, user_id, amount) VALUES (?, ?, ?)';
    try {
        const [result] = await db.promise().query(query, [ngoId, userId, amount]);
        return result;
    } catch (error) {
        throw error;
    }
};


const fetchNGOpostVoluntiring = async (id) => {
    return new Promise((resolve, reject) => {
        const query = "SELECT v.* FROM volunteering_opportunities AS v INNER JOIN ngo AS n ON v.ngo_id = n.ngo_id WHERE n.user_id = ?";
        db.query(query, [id], (err, result) => {
            if (err) {
                return reject(err)
            }
            if (result.length === 0) {
                return resolve(null)
            }
            resolve(result)
        })
    });
};

const deleteNgoFollower = async (userId, ngoId) => {
    const query = 'DELETE FROM ngo_followers WHERE user_id = ? AND ngo_id = ?';
    try {
        const [result] = await db.promise().query(query, [userId, ngoId]);
        return result;
    } catch (error) {
        throw error;
    }
};

module.exports = {
    findUserByEmail,
    createUser,
    findUserById,
    findByToken,
    updatePassword,
    consumeToken,
    fetchUserFollowings,
    fetchUserSubscription,
    fetchUserDonation,
    storeResetToken,
    storeUserImage,
    fetchUserImage,
    deleteNgoFollower,
    deleteUserSubscription,
    fetchNGOpostVoluntiring,
    addDonate
};
//fetchUserFollowers